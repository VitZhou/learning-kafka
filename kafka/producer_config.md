# 生产者配置
| 属性名 | 描述 |	类型|	默认值|	有效值|	重要性|
|--------|--------|--------|--------|--------|--------|
|    acks    |    在承诺请求完成之前,生产者要求Leader收到的确认number.这样可以控制已发送记录的耐久性.允许以下设置:<br>acks=0,如果设置为零,则生产者将不会等待服务器的任何确认.该记录将立即添加到socket buffer并被认为已发送.在这种情况下,不能保证服务器已接收到记录,重试配置将不会生效(因为客户端通常不会知道有任何故障).每个记录返回的偏移量将始终设置为-1;<br>acks=1,这将意味着leader会将记录写入其本地日志,但不会等待所有关注者的完整确认.在这种情况下,如果leader在确认记录之后,但是follower复制之前挂了,该记录就会丢失;<br>acks=all,这意味着领导者将等待全套同步副本来确认记录.只要至少有一个同步处理副本仍然存在,这将保证记录不会丢失.这是最强有力的保证.这相当于acks = -1设置。|    String    |    1    |  [all, -1, 0, 1]      |    高    |
| key.serializer| key实现序列化Serializer接口的类 |class|||高|
| key.serializer| value实现序列化Serializer接口的类 |class|||高|
| retries	|设置大于零的值将导致客户端重新发送发送失败并发生潜在的瞬时错误的记录。 请注意，此重试与收到错误时客户端重新发送记录无异。 允许重试，而不将max.in.flight.requests.per.connection设置为1(即该值不为0且不为1)将潜在地更改记录的顺序，因为如果两个批次发送到单个分区，并且第一个失败并重试，但第二个成功，则记录 在第二批可能会出现第一个位置	|	int|	0|[0,...,2147483647]	|	高|
| batch.size	|producer将试图批处理消息记录，以减少请求次数。这将改善client与server之间的性能。这项配置控制默认的批量处理消息字节数。</br>不会试图处理大于这个字节数的消息字节数。</br>发送到brokers的请求将包含多个批量处理，其中会包含对每个partition的一个请求。</br>较小的批量处理数值比较少用，并且可能降低吞吐量（0则会仅用批量处理）。较大的批量处理数值将会浪费更多内存空间，这样就需要分配特定批量处理数值的内存大小。|int	|16384	|	[0,...]|	中|
|	linger.ms|producer组将会汇总任何在请求与发送之间到达的消息记录一个单独批量的请求。通常来说，这只有在记录产生速度大于发送速度的时候才能发生。然而， 在某些条件下，客户端将希望降低请求的数量，甚至降低到中等负载一下。这项设置将通过增加小的延迟来完成--即，不是立即发送一条记录，producer将会等待给定的延迟时间以允许其他消息记录发送，这些消息记录可以批量处理。这可以认为是TCP种Nagle的算法类似。这项设置设定了批量处理的更高的 延迟边界：一旦我们获得某个partition的batch.size，他将会立即发送而不顾这项设置，然而如果我们获得消息字节数比这项设置要小的多，我们需要“linger”特定的时间以获取更多的消息。 这个设置默认为0，即没有延迟。设定linger.ms=5，例如，将会减少请求数目，但是同时会增加5ms的延迟。|long	|0	|[0,...]|中	|
|buffer.memory	|producer可以用来缓存数据的内存大小。如果数据产生速度大于向broker发送的速度，producer会阻塞或者抛出异常，以“block.on.buffer.full”来表明。</br>这项设置将和producer能够使用的总内存相关，但并不是一个硬性的限制，因为不是producer使用的所有内存都是用于缓存。一些额外的内存会用于压缩（如果引入压缩机制），同样还有一些用于维护请求。	|long	|33554432	|[0,...]|	高|
|	|	|	|	|	|	|
|	|	|	|	|	|	|
|	|	|	|	|	|	|
|	|	|	|	|	|	|